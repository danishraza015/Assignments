# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/192FlyZhsx4e4PX-9YYC5-vC1qqSTUwq4

Q1 What are the five key concepts of Object-Oriented Programming (OOP)?

Ans The five key concepts of Object-Oriented Programming (OOP) are:

1 Encapsulation: This principle involves bundling the data (attributes) and the methods (functions) that operate on the data into a single unit called a class. Encapsulation restricts direct access to some of the object's components, which can help prevent unintended interference and misuse of the data. This is often achieved through access modifiers (like private, protected, and public).

2 Abstraction: Abstraction focuses on exposing only the essential features of an object while hiding the complex implementation details. This allows users to interact with objects at a high level without needing to understand the underlying complexity. Abstract classes and interfaces are common tools used to implement abstraction.

3 Inheritance: Inheritance is a mechanism that allows a new class (subclass or derived class) to inherit properties and behaviors (methods) from an existing class (superclass or base class). This promotes code reusability and establishes a hierarchical relationship between classes.

4 Polymorphism: Polymorphism allows objects to be treated as instances of their parent class, enabling one interface to be used for different underlying data types. This can be achieved through method overriding (where a subclass provides a specific implementation of a method already defined in its superclass) and method overloading (where multiple methods have the same name but different parameters).

5 Composition: Composition is a design principle that allows a class to contain references to objects of other classes, creating a "has-a" relationship. This enables the creation of complex types by combining simpler ones and promotes greater flexibility and maintainability in code.

These concepts work together to enable developers to create modular, maintainable, and scalable software systems.

Q2 Write a Python class for a `Car` with attributes for `make`, `model`, and `year`. Include a method to display
the car's information.

Ans Here's a simple Python class for a Car with the specified attributes and a method to display the car's information:
"""

class Car:
    def __init__(self, make, model, year):
        """Initialize the Car object with make, model, and year."""
        self.make = make
        self.model = model
        self.year = year

    def display_info(self):
        """Display the car's information."""
        info = f"Car Make: {self.make}\nCar Model: {self.model}\nCar Year: {self.year}"
        print(info)

# Example usage:
my_car = Car("Toyota", "Corolla", 2020)
my_car.display_info()

"""Explanation:
__init__ Method: Initializes the attributes make, model, and year when a Car object is created.
display_info Method: Prints the car's information in a readable format.
The example usage creates a Car object and displays its information.
You can modify or extend the class as needed!

Q3 Explain the difference between instance methods and class methods. Provide an example of each.

Ans In Python, instance methods and class methods are two types of methods that differ primarily in how they are called and what they operate on.

Instance Methods
Definition: Instance methods are functions that operate on an instance of the class. They take the instance (usually referred to as self) as their first parameter, allowing them to access the instance's attributes and other methods.
Usage: These methods are used when you want to perform an operation that relates to a specific instance of the class.
Example:
"""

class Dog:
    def __init__(self, name):
        self.name = name  # Instance attribute

    def bark(self):  # Instance method
        return f"{self.name} says Woof!"

# Creating an instance of Dog
my_dog = Dog("Buddy")
print(my_dog.bark())  # Output: Buddy says Woof!

"""Class Methods
Definition: Class methods operate on the class itself rather than on instances of the class. They are marked with the @classmethod decorator and take cls as their first parameter, which refers to the class.
Usage: Class methods are often used for factory methods that create instances of the class or for operations that pertain to the class as a whole, rather than any specific instance.
Example:
"""

class Dog:
    number_of_dogs = 0  # Class attribute

    def __init__(self, name):
        self.name = name
        Dog.number_of_dogs += 1  # Increment the class attribute

    @classmethod
    def total_dogs(cls):  # Class method
        return f"There are currently {cls.number_of_dogs} dogs."

# Creating instances of Dog
dog1 = Dog("Buddy")
dog2 = Dog("Max")

# Calling the class method
print(Dog.total_dogs())  # Output: There are currently 2 dogs.

"""Summary
Instance methods require an instance of the class and can access instance-specific data.
Class methods belong to the class itself and can access class-specific data. They are useful for operations that are relevant to the class rather than any particular instance.

Q4 How does Python implement method overloading? Give an example.

Ans In Python, method overloading is not natively supported in the same way as in some other programming languages like Java or C++. However, you can achieve similar behavior using default arguments or by checking the types of the arguments within a single method.

Example of Method Overloading in Python
Hereâ€™s an example demonstrating how you can use default parameters to simulate method overloading:
"""

class MathOperations:
    def add(self, a, b=0, c=0):
        return a + b + c

# Creating an instance of the class
math = MathOperations()

# Calling the method with different numbers of arguments
result1 = math.add(5)         # Only one argument
result2 = math.add(5, 10)     # Two arguments
result3 = math.add(5, 10, 15)  # Three arguments

print(result1)  # Output: 5
print(result2)  # Output: 15
print(result3)  # Output: 30

"""Explanation
Method Definition: The add method is defined with three parameters, but only the first one is required. The other two have default values.
Different Calls: Depending on how many arguments you provide when calling the add method, it behaves differently:
If you provide only one argument, it adds that to zero.
If you provide two arguments, it adds both.
If you provide all three arguments, it adds all three together.
Alternative: Using *args
You can also use *args to handle an arbitrary number of arguments:
"""

class MathOperations:
    def add(self, *args):
        return sum(args)

# Creating an instance of the class
math = MathOperations()

# Calling the method with different numbers of arguments
result1 = math.add(5)              # One argument
result2 = math.add(5, 10)          # Two arguments
result3 = math.add(5, 10, 15, 20)  # Four arguments

print(result1)  # Output: 5
print(result2)  # Output: 15
print(result3)  # Output: 50

"""Conclusion
In summary, while Python does not support method overloading in the traditional sense, you can mimic it using default parameters or variable-length argument lists.

Q5 What are the three types of access modifiers in Python? How are they denoted?

In Python, there are three main types of access modifiers that determine the visibility and accessibility of class attributes and methods. These modifiers are:

Public:

Denotation: No underscore prefix (e.g., attribute).
Accessibility: Public members can be accessed from anywhere, both inside and outside the class.
Protected:

Denotation: A single underscore prefix (e.g., _attribute).
Accessibility: Protected members are intended to be accessed only within the class and by subclasses. However, this is a convention rather than a strict enforcement; they can still be accessed from outside the class.
Private:

Denotation: A double underscore prefix (e.g., __attribute).
Accessibility: Private members are intended to be inaccessible from outside the class. Python performs name mangling to make it harder (but not impossible) to access these members from outside the class. For example, a private member named __attribute can be accessed with the name _ClassName__attribute, where ClassName is the name of the class.
Here's a quick example:
"""

class Example:
    def __init__(self):
        self.public_attr = "I am public"
        self._protected_attr = "I am protected"
        self.__private_attr = "I am private"

    def show_attributes(self):
        print(self.public_attr)
        print(self._protected_attr)
        print(self.__private_attr)

obj = Example()
print(obj.public_attr)        # Accessible
print(obj._protected_attr)    # Accessible, but not recommended
# print(obj.__private_attr)   # Raises AttributeError
print(obj._Example__private_attr)  # Accessing private attribute through name mangling

"""These access modifiers help to encapsulate the data and promote better software design practices by controlling how data is accessed and modified.

Q6  Describe the five types of inheritance in Python. Provide a simple example of multiple inheritance.

Ans In Python, inheritance allows a class to inherit attributes and methods from another class, promoting code reuse and organization. There are five main types of inheritance:

1 Single Inheritance:

In single inheritance, a class (subclass) inherits from one parent class (superclass).
Example:
"""

class Animal:
    def speak(self):
        return "Animal speaks"

class Dog(Animal):
    def bark(self):
        return "Dog barks"

dog = Dog()
print(dog.speak())  # Output: Animal speaks

"""2 Multiple Inheritance:

In multiple inheritance, a class can inherit from more than one parent class.
Example:
"""

class Canine:
    def bark(self):
        return "Bark"

class Pet:
    def play(self):
        return "Playtime!"

class Dog(Canine, Pet):
    pass

dog = Dog()
print(dog.bark())  # Output: Bark
print(dog.play())  # Output: Playtime!

"""3 Multilevel Inheritance:

In multilevel inheritance, a class inherits from a class that is also derived from another class.
Example:
"""

class Animal:
    def speak(self):
        return "Animal speaks"

class Dog(Animal):
    def bark(self):
        return "Dog barks"

class Puppy(Dog):
    def weep(self):
        return "Puppy weeps"

puppy = Puppy()
print(puppy.speak())  # Output: Animal speaks
print(puppy.bark())   # Output: Dog barks
print(puppy.weep())   # Output: Puppy weeps

"""4 Hierarchical Inheritance:

In hierarchical inheritance, multiple classes inherit from a single parent class.
Example:
"""

class Animal:
    def speak(self):
        return "Animal speaks"

class Dog(Animal):
    def bark(self):
        return "Dog barks"

class Cat(Animal):
    def meow(self):
        return "Cat meows"

dog = Dog()
cat = Cat()
print(dog.speak())  # Output: Animal speaks
print(cat.speak())  # Output: Animal speaks

"""5 Hybrid Inheritance:

Hybrid inheritance is a combination of two or more types of inheritance.
Example:
"""

class Animal:
    def speak(self):
        return "Animal speaks"

class Canine(Animal):
    def bark(self):
        return "Bark"

class Feline(Animal):
    def meow(self):
        return "Meow"

class Dog(Canine):
    pass

class Cat(Feline):
    pass

class Wolf(Canine, Feline):
    pass

wolf = Wolf()
print(wolf.speak())  # Output: Animal speaks
print(wolf.bark())   # Output: Bark
print(wolf.meow())   # Raises an error since Wolf doesn't inherit from Feline

"""Simple Example of Multiple Inheritance
Here's a more detailed example of multiple inheritance
"""

class Writer:
    def write(self):
        return "Writing content"

class Artist:
    def draw(self):
        return "Drawing art"

class CreativePerson(Writer, Artist):
    def create(self):
        return "Creating something amazing"

# Creating an instance of CreativePerson
person = CreativePerson()
print(person.write())  # Output: Writing content
print(person.draw())   # Output: Drawing art
print(person.create())  # Output: Creating something amazing

"""In this example, the CreativePerson class inherits from both Writer and Artist, allowing it to access the methods from both parent classes.

Q7 What is the Method Resolution Order (MRO) in Python? How can you retrieve it programmatically?

Ans The Method Resolution Order (MRO) in Python is the order in which base classes are looked up when searching for a method in a class hierarchy. It is particularly important in multiple inheritance scenarios where a class can inherit from more than one parent class. The MRO helps to determine which method or attribute is accessed when there are multiple paths to it.

Python uses the C3 linearization algorithm (or C3 superclass linearization) to determine the MRO, ensuring a consistent order that respects the inheritance hierarchy and the order of base classes.

How to Retrieve MRO Programmatically
You can retrieve the MRO of a class using the __mro__ attribute or the mro() method. Hereâ€™s how to do both:

1 Using __mro__:
"""

class A:
    pass

class B(A):
    pass

class C(A):
    pass

class D(B, C):
    pass

print(D.__mro__)

"""2 Using mro():"""

print(D.mro())

"""Both approaches will return the same result, which is a tuple that lists the classes in the order they will be searched when looking for a method or attribute. For example, the output for the above code will look like this:"""

(<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)

"""This indicates that Python will first look for methods in D, then in B, then in C, followed by A, and finally in the built-in object class.

Q8 Create an abstract base class `Shape` with an abstract method `area()`. Then create two subclasses
`Circle` and `Rectangle` that implement the `area()` method.

Ans Here's how you can create an abstract base class Shape with an abstract method area(), and then implement two subclasses Circle and Rectangle in Python:
"""

from abc import ABC, abstractmethod
import math

# Abstract Base Class
class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

# Subclass for Circle
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return math.pi * (self.radius ** 2)

# Subclass for Rectangle
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

# Example Usage
circle = Circle(5)
print(f"Circle Area: {circle.area()}")  # Output: Circle Area: 78.53981633974483

rectangle = Rectangle(4, 6)
print(f"Rectangle Area: {rectangle.area()}")  # Output: Rectangle Area: 24

"""Explanation:
Abstract Base Class Shape:

Defined using the ABC module.
Contains an abstract method area(), which must be implemented by subclasses.
Subclass Circle:

Initializes with a radius.
Implements the area() method using the formula for the area of a circle.
Subclass Rectangle:

Initializes with width and height.
Implements the area() method using the formula for the area of a rectangle.
Example Usage:
The example shows how to create instances of Circle and Rectangle, and calls their respective area() methods to calculate and print their areas.

Q9 Demonstrate polymorphism by creating a function that can work with different shape objects to calculate
and print their areas

Ans Polymorphism allows objects of different classes to be treated as objects of a common superclass. In the context of shapes, you can create a base class (e.g., Shape) and derived classes (e.g., Circle, Rectangle, and Triangle). Each derived class will implement its own method for calculating the area. Here's how you can implement this in Python:
"""

import math

# Base class
class Shape:
    def area(self):
        raise NotImplementedError("Subclasses must implement this method")

# Derived class for Circle
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return math.pi * (self.radius ** 2)

# Derived class for Rectangle
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

# Derived class for Triangle
class Triangle(Shape):
    def __init__(self, base, height):
        self.base = base
        self.height = height

    def area(self):
        return 0.5 * self.base * self.height

# Function to calculate and print the area of different shapes
def print_area(shape):
    print(f"The area of the {shape.__class__.__name__} is: {shape.area()}")

# Creating instances of different shapes
circle = Circle(5)
rectangle = Rectangle(4, 6)
triangle = Triangle(3, 7)

# Using the print_area function with different shape objects
print_area(circle)      # Output: The area of the Circle is: 78.53981633974483
print_area(rectangle)   # Output: The area of the Rectangle is: 24
print_area(triangle)    # Output: The area of the Triangle is: 10.5

"""Explanation:
Base Class (Shape): This class defines a method area() that must be overridden by any subclass, ensuring that every shape has a way to calculate its area.
Derived Classes (Circle, Rectangle, Triangle): Each class implements its version of the area() method specific to its geometric formula.
Function (print_area): This function takes a Shape object as an argument and prints its area by calling the area() method.
When you run this code, it demonstrates polymorphism by allowing different shape objects to be processed through the same function.

Q10 Implement encapsulation in a `BankAccount` class with private attributes for `balance` and`account_number`. Include methods for deposit, withdrawal, and balance inquiry.

Ans Here's a simple implementation of a BankAccount class in Python that demonstrates encapsulation by using private attributes for balance and account_number. The class includes methods for depositing, withdrawing, and inquiring the balance.
"""

class BankAccount:
    def __init__(self, account_number, initial_balance=0):
        self.__account_number = account_number  # Private attribute
        self.__balance = initial_balance          # Private attribute

    def deposit(self, amount):
        """Deposits a specified amount into the account."""
        if amount > 0:
            self.__balance += amount
            print(f"Deposited: ${amount:.2f}. New balance: ${self.__balance:.2f}.")
        else:
            print("Deposit amount must be positive.")

    def withdraw(self, amount):
        """Withdraws a specified amount from the account, if sufficient funds are available."""
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            print(f"Withdrew: ${amount:.2f}. New balance: ${self.__balance:.2f}.")
        else:
            print("Insufficient funds or invalid withdrawal amount.")

    def get_balance(self):
        """Returns the current balance of the account."""
        return self.__balance

    def get_account_number(self):
        """Returns the account number."""
        return self.__account_number

# Example usage:
if __name__ == "__main__":
    account = BankAccount("123456789", 1000)
    account.deposit(500)
    account.withdraw(200)
    print(f"Current balance: ${account.get_balance():.2f}")
    print(f"Account number: {account.get_account_number()}")

"""Explanation:
Private Attributes: __account_number and __balance are private attributes, indicated by the double underscore prefix (__). This means they cannot be accessed directly from outside the class.
Methods:
deposit(amount): Adds the specified amount to the balance, ensuring the amount is positive.
withdraw(amount): Deducts the specified amount from the balance if there are sufficient funds.
get_balance(): Returns the current balance.
get_account_number(): Returns the account number.
Usage:
You can create a BankAccount object and call its methods to manage the account, ensuring that the internal state remains protected from external modifications.

Q11Write a class that overrides the `__str__` and `__add__` magic methods. What will these methods allow
you to do?

Ans In Python, magic methods (also known as dunder methods) allow you to define the behavior of your custom objects for built-in operations. The __str__ method is used to return a string representation of an object, while the __add__ method allows you to define the behavior of the addition operator (+) for your objects.

Here's a simple example of a class that overrides both __str__ and __add__:
"""

class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __str__(self):
        return f"Vector({self.x}, {self.y})"

    def __add__(self, other):
        if isinstance(other, Vector):
            return Vector(self.x + other.x, self.y + other.y)
        return NotImplemented

# Example usage
v1 = Vector(2, 3)
v2 = Vector(4, 5)

# Using __str__ method
print(v1)  # Output: Vector(2, 3)

# Using __add__ method
v3 = v1 + v2
print(v3)  # Output: Vector(6, 8)

"""Explanation
__init__ Method: Initializes the Vector objects with x and y coordinates.

__str__ Method: This method provides a human-readable string representation of the Vector object. When you call print(v1), it will display Vector(2, 3) instead of the default representation (which includes the object's memory address).

__add__ Method: This method defines how to add two Vector objects together using the + operator. In this case, it returns a new Vector with the sum of the corresponding x and y values. If the object being added is not a Vector, it returns NotImplemented, which allows Python to handle the operation appropriately if possible (e.g., raise an error).

Benefits of Overriding These Methods
Custom String Representation: By overriding __str__, you can control how instances of your class are represented as strings, making it easier to understand the output, especially when debugging or logging.

Operator Overloading: By overriding __add__, you can make your objects work seamlessly with Python's arithmetic operators, enhancing their usability and making your code more intuitive and expressive. For example, v1 + v2 feels natural when working with vectors.

Q12 Create a decorator that measures and prints the execution time of a function.

Ans You can create a Python decorator that measures the execution time of a function by using the time module. Here's a simple implementation of such a decorator:
"""

import time

def time_it(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()  # Record the start time
        result = func(*args, **kwargs)  # Call the original function
        end_time = time.time()  # Record the end time
        execution_time = end_time - start_time  # Calculate the execution time
        print(f"Execution time of {func.__name__}: {execution_time:.6f} seconds")
        return result  # Return the result of the original function
    return wrapper

# Example usage
@time_it
def example_function(n):
    total = 0
    for i in range(n):
        total += i
    return total

# Call the decorated function
result = example_function(1000000)

"""How It Works:
Decorator Definition: The time_it function takes a function (func) as its argument and defines a nested wrapper function.
Timing: Inside the wrapper, it records the start time, calls the original function, and then records the end time.
Execution Time Calculation: The difference between the end and start times gives the execution time, which is printed out.
Returning the Result: Finally, the wrapper returns the result of the original function.
Example Usage:
You can decorate any function with @time_it, and it will print the execution time whenever that function is called.

Q13 Explain the concept of the Diamond Problem in multiple inheritance. How does Python resolve it?

Ans The Diamond Problem is a common issue in object-oriented programming languages that support multiple inheritance. It arises when a class inherits from two classes that have a common superclass. The scenario creates a diamond-shaped inheritance structure:
"""

A
       / \
      B   C
       \ /
        D

"""In this example:

Class A is the superclass.
Classes B and C both inherit from A.
Class D inherits from both B and C.
The problem occurs when class D attempts to inherit attributes or methods from class A through both B and C. There are several potential issues:

Ambiguity: If D tries to call a method or access an attribute that exists in A, itâ€™s unclear whether it should use the version from B or C.
Duplication: If A has state (like attributes) that gets initialized in both B and C, class D might end up with two separate instances of A, which could lead to inconsistent state.
How Python Resolves the Diamond Problem
Python uses a method resolution order (MRO) to resolve the Diamond Problem. Hereâ€™s how it works:

C3 Linearization: Python uses the C3 linearization algorithm (also known as C3 superclass linearization) to determine the order in which classes are searched for methods and attributes. This ensures a consistent order of resolution while preserving the order of inheritance.

Single Call to Each Class: When searching for a method or attribute, Python looks through the MRO, which contains the classes in the order they will be checked. Each class is checked only once in the order determined by the linearization.

Using the super() Function: The super() function in Python allows you to call methods from parent classes in a way that respects the MRO, thus avoiding ambiguity.

Example
Hereâ€™s a simple illustration of how Python resolves the Diamond Problem:
"""

class A:
    def show(self):
        print("A's method")

class B(A):
    def show(self):
        print("B's method")

class C(A):
    def show(self):
        print("C's method")

class D(B, C):
    pass

d = D()
d.show()

"""In this example, if you call d.show(), Python will use the MRO to determine which show method to call. The MRO for D can be viewed using:"""

print(D.mro())

"""This will return the order in which classes are searched, for example:"""

[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]

"""Summary
Python resolves the Diamond Problem by using the C3 linearization algorithm to create a method resolution order that ensures each class is only called once. This approach avoids ambiguity and maintains a clear and consistent inheritance structure.

Q14 Write a class method that keeps track of the number of instances created from a class.

Ans You can achieve this by using a class variable to keep track of the number of instances created. Below is an example of a Python class that demonstrates this functionality:
"""

class MyClass:
    # Class variable to keep track of the number of instances
    instance_count = 0

    def __init__(self):
        # Increment the instance count each time a new instance is created
        MyClass.instance_count += 1

    @classmethod
    def get_instance_count(cls):
        # Class method to return the current instance count
        return cls.instance_count

# Example usage:
obj1 = MyClass()
obj2 = MyClass()
obj3 = MyClass()

# Get the number of instances created
print(MyClass.get_instance_count())  # Output: 3

"""Explanation:
instance_count: This class variable keeps track of the number of instances created.
__init__: The constructor increments instance_count each time a new instance of MyClass is created.
get_instance_count: This class method returns the current count of instances. It uses the cls parameter to reference the class itself.
You can create as many instances of MyClass as needed, and calling MyClass.get_instance_count() will always return the correct number of instances.

Q15 Implement a static method in a class that checks if a given year is a leap year.

Ans You can implement a static method in a class to check if a given year is a leap year using the following Python code:
"""

class YearUtils:
    @staticmethod
    def is_leap_year(year):
        """Check if a given year is a leap year."""
        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
            return True
        return False

# Example usage
year = 2024
if YearUtils.is_leap_year(year):
    print(f"{year} is a leap year.")
else:
    print(f"{year} is not a leap year.")

"""Explanation:
The method is_leap_year checks:
If a year is divisible by 4 and not divisible by 100, it is a leap year.
If a year is divisible by 400, it is also a leap year.
The method returns True if the year is a leap year, and False otherwise.
You can call this static method without needing to create an instance of the YearUtils class.
"""